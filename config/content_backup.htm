<h1>About</h1>
<p>課程名稱: 計算機程式</p>
<p>示範網站: <a href="https://mde.tw/cp_demo">https://mde.tw/cp_demo</a></p>
<p>示範倉儲: <a href="https://github.com/mdecycu/cp_demo">https://github.com/mdecycu/cp_demo</a> </p>
<p>課程評分:</p>
<p style="padding-left: 30px;"><span style="background-color: #ffff00;">學習心得報告 (60%)</span> - MS Teams 線上參與，<span style="background-color: #ccffcc;">6人一組</span>每三週發表學習心得。</p>
<p style="padding-left: 60px;">w3、w7、w10、w14、w17、w18</p>
<p style="padding-left: 60px;">學習心得報告主題:</p>
<p style="padding-left: 60px;">w3: 什麼是 git, GitHub, gist 與 cmsimde? 如何使用這些工具？為什麼要使用這些工具？ (<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/71ff1c69dd233e6a5a83dd60997950de/raw/b4134dc3724f9c6aa1de7534a74f298288de0fa5/round_dot_move.py">動態模擬</a>)</p>
<p style="padding-left: 60px;">w7: Brython 是什麼？如何在瀏覽器配置 Brython 環境？ Brython 能做什麼？ (<a href="https://mde.tw/cp2025/content/Brython.html">Brython</a>, <a href="https://mde.tw/cp2025/content/Robot_ex.html">Examples</a>)</p>
<p style="padding-left: 60px;">w10: 如何在瀏覽器中模擬機器人作動？ (<a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/58fed8bd2f5be98a6456a8dcae512011/raw/4019adba4ee4be19c35982d835bad8e7d83a7b2f/brython_robot4_ex1.py">機器人作動</a>)</p>
<p style="padding-left: 60px;">w14: 在瀏覽器中模擬機器人作動的目的是什麼？ (<a href="/downloads/otto_robot.7z">otto_robot.7z</a>, <a href="https://mde.tw/cad2025/content/Homework.html">Plotter</a>, <a href="/downloads/open_duck_mini.7z">open_duck_mini.7z</a> ,<a href="https://webots.cloud/AcTNYs0">https://webots.cloud/AcTNYs0</a>)</p>
<p style="padding-left: 60px;">w17 (<span style="background-color: #ccffcc;">1b 採 Youtube 影片簡報</span>): 計算機程式課程學到了什麼？</p>
<p style="padding-left: 60px;">w18: 課程總結</p>
<p style="padding-left: 30px;"><span style="background-color: #ffff00;">個人與分組網站維護 (40%)</span> - 每週至少兩次推送與課程進度相關的學習內容與心得。</p>
<p style="padding-left: 60px;">w9 期中自評、w18 期末自評</p><h1>Project</h1>
<p>既存技術:</p>
<p style="padding-left: 30px;"><a href="https://github.com/scrum-1/respysive-slide">https://github.com/scrum-1/respysive-slide</a></p>
<p>專案簡介：非同步分散式 Reveal.js 協同簡報編輯系統</p>
<p>各學員利用 <a href="https://github.com/fbxyz/respysive-slide">https://github.com/fbxyz/respysive-slide</a> 模組，以位於 downloads 目錄的 <a href="/downloads/reveal_file.py">reveal_file.py</a> 建立簡報。(<a href="https://mde.tw/cp_demo/reveal/index.html">簡報結果</a>)</p>
<p>各學員進行協同倉儲內容編輯時，可以先將版本推送至個人倉儲分支，待階段性內容完成後，再設法與主分支或其他測試用分支進行合併。若合併之版本內容有衝突(同位置的新舊版本內容取捨)，則必須設法解決衝突內容後，再進行後續的新增、提交與推送。</p><h1>Python</h1>
<p><a href="https://github.com/mdecycu/python_2025/blob/main/%E7%AC%AC01%E8%AA%B2%EF%BC%9A%E5%88%9D%E8%AD%98Python.md">Python 程式教材</a> (中文)</p>
<p>透過 <a href="https://mde.tw/cp2025/content/Robot_ex.html">https://mde.tw/cp2025/content/Robot_ex.html</a> 學習 Python 程式語法。</p>
<p>Python 基本語法: <a href="https://link.springer.com/chapter/10.1007/978-3-031-90522-3_1">Python essential</a> (英文，只能在校網擷取)</p>
<p>Python 變數宣告原則:</p>
<p>在 Python 中，變數宣告（Variable Declaration）相較於其他語言（如 Java 或 C++）來得簡單，因為 Python 是動態型別語言。以下是 Python 宣告變數的原則與最佳實踐：</p>
<p><span style="background-color: #ffff99;">一、不需明確指定型別</span></p>
<p style="padding-left: 30px;"><span style="background-color: #ccffcc;">Python 是動態型別語言，你不需要指定變數型別</span>，解譯器會根據賦值自動判斷。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">x = 10        # 整數
name = "Amy"  # 字串
pi = 3.14     # 浮點數
</pre>
<p><span style="background-color: #ffff99;">二、變數名稱命名規則</span></p>
<p style="padding-left: 30px;">合法命名：<br/><br/><span style="background-color: #ccffcc;">可以包含字母、數字、底線（_）</span><br/><br/><span style="background-color: #ccffcc;">不能以數字開頭</span><br/><br/><span style="background-color: #ccffcc;">不能使用 Python 保留的關鍵字(35個)</span>:</p>
<p style="padding-left: 60px;">['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', '<span style="background-color: #ffcc99;">def</span>', 'del', 'elif', '<span style="background-color: #ffcc99;">else</span>', 'except', 'finally', '<span style="background-color: #ffcc99;">for</span>', 'from', 'global', '<span style="background-color: #ffcc99;">if</span>', '<span style="background-color: #ffcc99;">import</span>', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']</p>
<p style="padding-left: 30px;">利用 keyword 模組，<a href="https://mde.tw/cp_demo/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/da44925c2f9694f825c2525edfc80367f327ca5e/print_keywords.py">列出 Python 所保留的關鍵字</a>:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import keyword

# 印出關鍵字清單
print("Python 保留關鍵字有：")
print(keyword.kwlist)

# 印出總數
print("\n關鍵字總數：", len(keyword.kwlist))</pre>
<p><span style="background-color: #ffff99;">三、使用有意義的變數名稱</span></p>
<p style="padding-left: 30px;">例如: grid_width = 10</p>
<p><span style="background-color: #ffff99;">四、遵守 Python 命名慣例（<a href="https://peps.python.org/pep-0008/" style="background-color: #ffff99;">PEP 8</a>）</span></p>
<p style="padding-left: 30px;"><span style="background-color: #ccffcc;">小寫 + 底線 用於變數和函數名稱：total_price</span><br/><br/><span style="background-color: #ccffcc;">全大寫 用於常數：MAX_SIZE</span><br/><br/><span style="background-color: #ccffcc;">大駝峰式（PascalCase） 用於類別名稱：StudentProfile</span></p>
<p><span style="background-color: #ffff99;">五、Python 變數名稱區分大小寫</span></p>
<p style="padding-left: 30px;">length 與 Length 是兩個不同的變數名稱</p>
<p><span style="background-color: #ffff99;">六、變數可重新指派不同型別（動態型別特性）</span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">x = 100       # 整數
x = "hello"   # 變成字串
</pre>
<p><span style="background-color: #ffff99;">七、可同時宣告多個變數（多重賦值）</span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">a, b, c = 1, 2, 3
x = y = z = 0  # 所有變數都為 0
</pre>
<p></p>
<hr/>
<p>有關 w3 簡報</p>
<p><a href="/downloads/1a_w3_about_presentation.txt">1a_w3_about_presentation.txt</a></p>
<p>先處理<span style="background-color: #ccffcc;">奇數正方形網格區域</span>，讓機器人走過每一格: <a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/295cc3af8240aa9b88f9c3a36b676f71135023fa/for_odd_square_grid_area.py">執行結果</a>。</p>
<p>針對<span style="background-color: #ccffcc;">長方形網格區域</span>，讓機器人也能走過每一格: <a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/37d7b11d9da66ce781e11372b601fac28f1ee279/for_any_rectangle_grid_area.py">執行結果</a>。</p>
<hr/>
<p>w3: 什麼是 git, GitHub, gist 與 cmsimde? 如何使用這些工具？為什麼要使用這些工具？</p>
<hr/>
<p>原始提問:<br/><br/>下個禮拜我們這一組有六位組員，被要求要上台報告有關計算機程式課程的學習心得，題目是:w3: 什麼是 git，GitHub，gist 與 cmsimde? 如何使用這些工具？為什麼要使用這些工具？, 上課時老師只稍微說明一下，但要我們自己找資料聯席，並且六人逐一上台報告心得， 請用大一新生的程度，幫我們這六位組員準備講稿,並且準備六個人分別要上台展示的指令及內容, 講稿請詳細解說, 並列出參考網站來源, 非常感謝。<br/><br/>要求修飾提問稿:<br/><br/>請幫我們將以下的文字稍微整理一下, 讓他比較通順易懂: 下個禮拜我們這一組有六位組員，被要求要上台報告有關計算機程式課程的學習心得，題目是:w3: 什麼是 git，GitHub，gist 與 cmsimde? 如何使用這些工具？為什麼要使用這些工具？, 上課時老師只稍微說明一下，但要我們自己找資料聯席，並且六人逐一上台報告心得， 請用大一新生的程度，幫我們這六位組員準備講稿,並且準備六個人分別要上台展示的指令及內容, 講稿請詳細解說, 並列出參考網站來源, 非常感謝。<br/><br/>結果:<br/><br/>下個禮拜我們組有六位組員，會上台報告計算機程式課程的學習心得。報告的題目是：「W3: 什麼是 Git、GitHub、Gist 和 CMSIMDE？如何使用這些工具？為什麼要使用這些工具？」老師在課堂上簡單提過這些工具，但並沒有深入講解，並且要求我們自己搜尋資料，準備報告內容。我們的報告會分成六部分，每位組員負責介紹一個主題，逐一上台展示。<br/><br/>因此，請幫我們為六位組員準備講稿，內容要符合大一新生的理解程度，並且每個人要有具體的指令展示與解說。希望講稿能詳細說明這些工具的基本概念、操作方法及為什麼我們需要使用它們，並附上參考網站來源。<br/><br/>感謝你的幫忙！</p>
<p>其他相關提問:</p>
<p>請將以下的 markdown 轉為 html, 其中的 head 標註請用 h4 表示, 不要使用 h3, h2 或 h1。</p>
<p>請再更詳細說明每一個重點，並且列出能直接在電腦上邊操作邊說明的內容，以及操作步驟，還有操作展示的目的。</p>
<p>回覆內容請用 html 表示，而 head 標註請用 h4 表示, 不要使用 h3, h2 或 h1。</p>
<p data-pm-slice="1 1 []">請詳細說明，上述的議題與操作流程跟計算機程式課程有甚麼關係?使用這些工具有甚麼優點?若不使用又會怎樣?</p>
<hr/>
<p>參考回覆:</p>
<p>這是一次很好的學習機會，能夠深入了解 Git、GitHub、Gist 和 CMSIMDE 的使用和意義，並且學會如何在報告中表達這些技術對程式設計的影響。接下來，我會為你們準備一個詳細的講稿，並且安排好每位組員需要上台展示的內容。每個人的講稿會著重於解釋和展示基本概念與操作。</p>
<h4><strong>整體講稿大綱：</strong></h4>
<ol>
<li><strong>組員 1：什麼是 Git？</strong></li>
<li><strong>組員 2：Git 的基本命令與操作</strong></li>
<li><strong>組員 3：什麼是 GitHub？</strong></li>
<li><strong>組員 4：如何使用 GitHub 進行協作</strong></li>
<li><strong>組員 5：什麼是 Gist？</strong></li>
<li><strong>組員 6：CMSIMDE 和為什麼要使用 Git、GitHub 和 Gist</strong></li>
</ol>
<h4><strong>1. 組員 1：什麼是 Git？</strong></h4>
<p><strong>講稿內容：</strong></p>
<p>大家好，今天我將介紹 Git。Git 是一個分佈式版本控制系統（Version Control System, VCS），由 Linus Torvalds（Linux 的創始人）開發。它主要用來追蹤程式碼的變更，並且能夠幫助多人協作開發同一個專案。</p>
<ul>
<li><strong>版本控制：</strong> Git 讓你能夠對每次程式碼的變動進行記錄和管理，並且隨時回到歷史版本。這對於多人協作開發來說非常重要，因為每個人都能夠清楚地知道自己和別人對程式碼的修改。</li>
<li><strong>分佈式：</strong> Git 是分佈式的，這意味著每個開發者的電腦上都有一份完整的程式碼庫。即使離線也可以進行編輯和提交，後續再與其他開發者同步。</li>
</ul>
<p><strong>參考資料：</strong></p>
<ul>
<li><a href="https://git-scm.com/">Git 官方網站</a></li>
<li><a href="https://www.git-scm.com/book/zh-tw/v2">簡介：Git 是什麼？</a></li>
</ul>
<hr/>
<h4><strong>2. 組員 2：Git 的基本命令與操作</strong></h4>
<p><strong>講稿內容：</strong></p>
<p>接下來，我將介紹 Git 的基本命令和操作。這些命令幾乎是每個程式開發者日常必學的。</p>
<ol>
<li><strong>初始化 Git 倉庫（初始化 repository）：</strong><br/> <code>git init</code><br/> 這個命令會創建一個新的 Git 倉庫，用來追蹤程式碼變更。</li>
<li><strong>檢查狀態：</strong><br/> <code>git status</code><br/> 用來檢查當前的版本控制狀態，例如哪些檔案已被修改、哪些尚未加入 Git 追蹤。</li>
<li><strong>添加文件到版本控制：</strong><br/> <code>git add &lt;檔案名&gt;</code><br/> 把修改的文件加入 Git 追蹤，這樣下一次提交時，Git 會記錄這些變更。</li>
<li><strong>提交變更：</strong><br/> <code>git commit -m "提交訊息"</code><br/> 用來將變更提交到本地的 Git 倉庫中，並附上描述這次修改的訊息。</li>
<li><strong>查看提交歷史：</strong><br/> <code>git log</code><br/> 用來查看所有提交的歷史紀錄。</li>
</ol>
<p><strong>參考資料：</strong></p>
<ul>
<li><a href="https://backlog.com/git-tutorial/cn/">Git 入門指南</a></li>
<li><a href="https://www.runoob.com/git/git-command-ref.html">Git 常用命令</a></li>
</ul>
<hr/>
<h4><strong>3. 組員 3：什麼是 GitHub？</strong></h4>
<p><strong>講稿內容：</strong></p>
<p>GitHub 是一個基於 Git 的雲端代碼託管平台。它可以讓開發者將本地的 Git 倉庫推送到雲端，並與其他人共享代碼。GitHub 使得程式碼存儲、協作和版本控制變得更加簡單和高效。</p>
<ul>
<li><strong>GitHub 的主要功能：</strong></li>
<ul>
<li><strong>代碼托管：</strong> GitHub 提供免費的代碼托管服務，可以讓開發者將程式碼儲存在雲端，並且輕鬆與他人共享。</li>
<li><strong>協作功能：</strong> 開發者可以通過 Fork、Pull Request 等功能來進行協作開發，這對於開源專案尤其重要。</li>
<li><strong>問題追蹤：</strong> GitHub 還有 Issues 功能，可以幫助團隊追蹤和管理程式中的 Bug 或新功能的開發。</li>
</ul>
</ul>
<p><strong>參考資料：</strong></p>
<ul>
<li><a href="https://github.com/">GitHub 官方網站</a></li>
<li><a href="https://guides.github.com/">GitHub 入門</a></li>
</ul>
<hr/>
<h4><strong>4. 組員 4：如何使用 GitHub 進行協作</strong></h4>
<p><strong>講稿內容：</strong></p>
<p>GitHub 是協作開發的利器。這裡，我們將介紹如何使用 GitHub 進行協作：</p>
<ol>
<li><strong>創建一個新的 GitHub 儲存庫（repository）：</strong><br/> 在 GitHub 上創建一個新的儲存庫，然後將本地的 Git 倉庫推送到這個儲存庫。<br/> <code>git remote add origin &lt;repository-url&gt;</code><br/> <code>git push -u origin master</code></li>
<li><strong>Fork 和 Pull Request：</strong><br/>
<ul>
<li><strong>Fork：</strong> 將他人的專案複製到自己的帳號下，這樣就可以在自己帳號中進行修改。</li>
<li><strong>Pull Request：</strong> 在修改完成後，通過 Pull Request 提交修改，向原作者請求合併（Merge）你的更改。</li>
</ul>
</li>
<li><strong>分支管理：</strong><br/> 在多人協作的情況下，通常每個開發者會創建自己的分支（branch），在完成開發後再合併（merge）到主分支。</li>
</ol>
<p><strong>參考資料：</strong></p>
<ul>
<li><a href="https://guides.github.com/activities/forking/">GitHub 協作指南</a></li>
<li><a href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request">如何創建 Pull Request</a></li>
</ul>
<hr/>
<h4><strong>5. 組員 5：什麼是 Gist？</strong></h4>
<p><strong>講稿內容：</strong></p>
<p>Gist 是 GitHub 提供的一個簡單的代碼分享和存儲工具，主要用來分享片段代碼或日常的小範例。</p>
<ul>
<li><strong>Gist 的特點：</strong></li>
<ul>
<li>Gist 允許開發者輕鬆分享代碼片段，並且可以選擇是否公開或私密。</li>
<li>每個 Gist 都有一個唯一的 URL，方便分享給他人。</li>
<li>支援版本控制，並且可以對 Gist 進行 Fork 和修改。</li>
</ul>
</ul>
<p><strong>參考資料：</strong></p>
<ul>
<li><a href="https://gist.github.com/">Gist 官方網站</a></li>
<li><a href="https://help.github.com/en/github/creating-cloning-and-archiving-repositories/creating-gists">如何使用 Gist</a></li>
</ul>
<hr/>
<h4><strong>6. 組員 6：CMSIMDE 和為什麼要使用 Git、GitHub 和 Gist</strong></h4>
<p><strong>講稿內容：</strong></p>
<p>最後，我們來談談 CMSIMDE 以及為什麼我們要使用 Git、GitHub 和 Gist。</p>
<ul>
<li><strong>CMSIMDE（Content Management System and Integrated Development Environment）：</strong> 這是一個綜合的開發環境，旨在幫助開發者管理和開發程式。它融合了內容管理系統和集成開發環境的功能，可以更高效地協作開發和版本管理。</li>
<li><strong>為什麼要使用 Git、GitHub 和 Gist：</strong>
<ul>
<li><strong>版本控制：</strong> Git 和 GitHub 讓開發者能夠追蹤程式碼的變更，防止程式碼丟失，並且能夠隨時回到舊版本。</li>
<li><strong>協作開發：</strong> GitHub 和 Gist 使得多人協作開發變得更加順利，無論是協同編寫代碼還是討論功能需求，都能在 GitHub 上輕鬆實現。</li>
<li><strong>便於分享：</strong> 透過 Gist，開發者能夠迅速分享代碼片段或小範例，這對於學習和交流非常有幫助。</li>
</ul>
</li>
</ul>
<p><strong>參考資料：</strong></p>
<ul>
<li><a href="https://www.cmsimde.com/">CMSIMDE 介紹</a></li>
<li><a href="https://gist.github.com/">GitHub 和 Gist 介紹</a></li>
</ul>
<hr/>
<p>進一步提問，要求補充更多資料:</p>
<p>請再更詳細說明每一個重點，並且列出能直接在電腦上邊操作邊說明的內容，以及操作步驟，還有操作展示的目的。</p>
<p>回覆內容請用 html 表示，而 head 標註請用 h4 表示, 不要使用 h3, h2 或 h1。</p>
<hr/>
<p>這是一次很好的學習機會，能夠深入了解 Git、GitHub、Gist 和 CMSIMDE 的使用和意義，並且學會如何在報告中表達這些技術對程式設計的影響。接下來，我會為你們準備一個詳細的講稿，並且安排好每位組員需要上台展示的內容。每個人的講稿會著重於解釋和展示基本概念與操作。</p>
<h4><strong>整體講稿大綱：</strong></h4>
<ol>
<li><strong>組員 1：什麼是 Git？</strong></li>
<li><strong>組員 2：Git 的基本命令與操作</strong></li>
<li><strong>組員 3：什麼是 GitHub？</strong></li>
<li><strong>組員 4：如何使用 GitHub 進行協作</strong></li>
<li><strong>組員 5：什麼是 Gist？</strong></li>
<li><strong>組員 6：CMSIMDE 和為什麼要使用 Git、GitHub 和 Gist</strong></li>
</ol>
<h4><strong>1. 組員 1：什麼是 Git？</strong></h4>
<p><strong>講稿內容：</strong></p>
<p>大家好，今天我將介紹 Git。Git 是一個分佈式版本控制系統（Version Control System, VCS），由 Linus Torvalds（Linux 的創始人）開發。它的目的是追蹤程式碼的變更，並協助多人協作開發。</p>
<p>Git 的兩大特點：</p>
<ul>
<li><strong>版本控制：</strong> 每次程式碼的變動都會被記錄，並且能夠隨時回到歷史版本。這樣即使有錯誤，也能夠快速恢復程式碼。</li>
<li><strong>分佈式：</strong> 每個開發者的電腦上都會有一份完整的程式碼庫，這讓開發者能夠在離線的情況下進行編輯，並在有網路時再進行同步。</li>
</ul>
<h4><strong>操作展示：</strong></h4>
<p><strong>目的：</strong> 理解 Git 如何管理程式碼版本並進行變更追蹤。</p>
<p>請依照下列步驟在電腦中實際操作：</p>
<ol>
<li><strong>建立一個新的 Git 倉庫：</strong>
<p>在你的終端機（Terminal）中，創建一個新的資料夾，然後初始化 Git 倉庫：</p>
<code>mkdir my_project &amp;&amp; cd my_project</code><br/> <code>git init</code>
<p>這個命令會創建一個新的 Git 倉庫。</p>
</li>
<li><strong>查看 Git 狀態：</strong>
<p>使用命令檢查當前 Git 倉庫的狀態：</p>
<code>git status</code>
<p>這會顯示哪些檔案有變更，但尚未被 Git 追蹤。</p>
</li>
<li><strong>創建檔案並提交變更：</strong>
<p>創建一個簡單的檔案：</p>
<code>echo "Hello, Git!" &gt; hello.txt</code><br/>
<p>然後使用以下命令將檔案添加到 Git 追蹤：</p>
<code>git add hello.txt</code><br/>
<p>最後提交變更：</p>
<code>git commit -m "Add hello.txt"</code></li>
</ol>
<h4><strong>2. 組員 2：Git 的基本命令與操作</strong></h4>
<p><strong>講稿內容：</strong></p>
<p>接下來，我將介紹 Git 的基本命令，這些是開發過程中最常使用的命令。</p>
<ul>
<li><strong>git init：</strong> 用來初始化一個新的 Git 倉庫。</li>
<li><strong>git add：</strong> 用來將修改過的檔案添加到 Git 追蹤列表。</li>
<li><strong>git commit：</strong> 用來提交檔案，將變更保存到版本庫。</li>
<li><strong>git status：</strong> 查看當前的工作區狀態，顯示檔案是否有變更。</li>
<li><strong>git log：</strong> 查看提交歷史。</li>
</ul>
<h4><strong>操作展示：</strong></h4>
<p><strong>目的：</strong> 熟悉並實際操作 Git 的基本命令。</p>
<p>請依照下列步驟在電腦中進行：</p>
<ol>
<li><strong>查看工作區狀態：</strong>
<p>使用命令檢查當前工作區的狀態：</p>
<code>git status</code></li>
<li><strong>查看 Git 提交歷史：</strong>
<p>顯示最近的提交紀錄：</p>
<code>git log</code>
<p>可以使用 `q` 退出日誌查看。</p>
</li>
</ol>
<h4><strong>3. 組員 3：什麼是 GitHub？</strong></h4>
<p><strong>講稿內容：</strong></p>
<p>GitHub 是基於 Git 的代碼託管平台，可以讓開發者將本地的 Git 倉庫上傳到雲端，並與其他人共享代碼。</p>
<ul>
<li><strong>代碼托管：</strong> GitHub 允許免費或付費的方式來儲存你的代碼，並可以方便地與他人協作。</li>
<li><strong>協作功能：</strong> 例如 Fork、Pull Request，這些功能使得開發者能夠在開源項目中協作。</li>
<li><strong>問題追蹤：</strong> GitHub 提供 Issues 功能，方便開發團隊追蹤問題和進度。</li>
</ul>
<h4><strong>操作展示：</strong></h4>
<p><strong>目的：</strong> 演示如何在 GitHub 上創建和管理倉庫。</p>
<p>請依照下列步驟操作：</p>
<ol>
<li><strong>創建 GitHub 倉庫：</strong>
<p>進入 GitHub 網站，點選 "New Repository" 並創建一個新的倉庫。</p>
</li>
<li><strong>將本地倉庫推送到 GitHub：</strong>
<p>在終端機中，執行以下命令：</p>
<code>git remote add origin https://github.com/yourusername/your-repository.git</code><br/> <code>git push -u origin master</code></li>
</ol>
<h4><strong>4. 組員 4：如何使用 GitHub 進行協作</strong></h4>
<p><strong>講稿內容：</strong></p>
<p>GitHub 使多人協作變得簡單。這裡介紹如何在 GitHub 上協作開發。</p>
<ul>
<li><strong>Fork：</strong> 將他人的倉庫複製到你的 GitHub 帳號下，這樣你就可以自由修改。</li>
<li><strong>Pull Request：</strong> 當你完成修改後，向原始倉庫發送 Pull Request 請求合併你的變更。</li>
<li><strong>分支管理：</strong> 每個開發者可以創建自己的分支來進行開發，避免直接修改主分支。</li>
</ul>
<h4><strong>操作展示：</strong></h4>
<p><strong>目的：</strong> 演示如何使用 GitHub 進行協作開發。</p>
<p>請依照下列步驟操作：</p>
<ol>
<li><strong>Fork 一個倉庫：</strong>
<p>在 GitHub 上找到一個開源專案，點選 "Fork" 將其複製到你的帳號。</p>
</li>
<li><strong>創建 Pull Request：</strong>
<p>修改 Fork 的倉庫後，點選 "Pull Request" 發送合併請求。</p>
</li>
</ol>
<h4><strong>5. 組員 5：什麼是 Gist？</strong></h4>
<p><strong>講稿內容：</strong></p>
<p>Gist 是 GitHub 提供的一個工具，讓開發者可以分享小片段的代碼或文檔。</p>
<h4><strong>操作展示：</strong></h4>
<p><strong>目的：</strong> 演示如何創建和分享 Gist。</p>
<p>請依照下列步驟操作：</p>
<ol>
<li><strong>創建 Gist：</strong>
<p>進入 Gist 網站，點選 "Create Gist"，並粘貼你想分享的代碼。</p>
</li>
<li><strong>分享 Gist：</strong>
<p>創建完後，你會獲得一個唯一的 URL，可以將這個 URL 分享給其他人。</p>
</li>
</ol>
<h4><strong>6. 組員 6：CMSIMDE 和為什麼要使用 Git、GitHub 和 Gist</strong></h4>
<p><strong>講稿內容：</strong></p>
<p>這部分將介紹 CMSIMDE 並討論使用 Git、GitHub 和 Gist 的重要性。</p>
<ul>
<li><strong>版本控制：</strong> 使用 Git 可以讓開發者記錄代碼的變更並輕鬆回滾。</li>
<li><strong>協作開發：</strong> GitHub 和 Gist 是協作開發的好工具，能讓多人輕鬆協同工作。</li>
<li><strong>簡化分享：</strong> 使用 Gist 可以快速分享代碼片段和文件。</li>
</ul>
<p>這些工具對於開發流程非常有幫助，無論是學習、開發還是協作，都能大大提高效率。</p>
<hr/>
<h4><strong>請詳細說明，上述的議題與操作流程跟計算機程式課程有甚麼關係?使用這些工具有甚麼優點?若不使用又會怎樣?</strong></h4>
<h4><strong>Git、GitHub、Gist 和 CMSIMDE 與計算機程式課程的關係</strong></h4>
<p>在計算機程式設計課程中，學習如何編寫程式、協作開發、管理程式碼變更，以及有效地共享代碼是非常重要的。Git、GitHub、Gist 和 CMSIMDE 是一些現代開發中不可或缺的工具，它們不僅有助於程式開發過程的管理，還能提高開發效率，促進團隊協作。以下將詳細說明這些工具與計算機程式課程的關係，以及它們的優點，並分析如果不使用這些工具可能帶來的後果。</p>
<h4><strong>1. Git 與程式設計課程的關係</strong></h4>
<p><strong>Git</strong> 是一個強大的版本控制工具，主要用來追蹤程式碼的變更，確保開發過程中的每個修改都有記錄，並且能夠隨時回到先前的版本。對於程式設計課程來說，Git 可以幫助學生管理自己的程式碼版本，防止在編寫程式時發生錯誤丟失，並且讓學生能夠在團隊合作中協同開發。</p>
<h4><strong>操作流程：</strong></h4>
<p><strong>目的：</strong> 學生使用 Git 來管理自己的程式碼變更和協作開發。</p>
<ol>
<li><strong>初始化本地倉庫：</strong>
<p>在學生開始編寫程式碼時，使用 `git init` 創建一個本地 Git 倉庫，開始管理程式碼的版本。</p>
</li>
<li><strong>提交程式碼：</strong>
<p>每當學生進行了一些變更（如修正錯誤或增加功能），可以使用 `git add` 和 `git commit` 來記錄和保存這些變更。</p>
</li>
<li><strong>查看變更歷史：</strong>
<p>學生可以使用 `git log` 查看所有的提交歷史，了解程式碼的變更情況。</p>
</li>
</ol>
<h4><strong>優點：</strong></h4>
<ul>
<li><strong>版本控制：</strong> Git 允許學生記錄每一次的程式碼變更，並能隨時回到歷史版本，這對於避免錯誤和修改衝突非常重要。</li>
<li><strong>協作開發：</strong> 在團隊專案中，Git 使得每個組員都能在自己的工作區域編寫程式碼，並能夠在需要時將自己的變更推送到主倉庫。</li>
</ul>
<h4><strong>不使用 Git 的後果：</strong></h4>
<ul>
<li><strong>程式碼丟失：</strong> 若學生不使用 Git，當程式碼出現錯誤或變更不當時，無法輕易回到之前的版本，可能會浪費大量時間來修復錯誤。</li>
<li><strong>難以協作：</strong> 團隊協作將變得困難，因為每個人可能會在不同的版本上工作，無法輕鬆合併所有的變更，甚至會導致代碼衝突。</li>
</ul>
<h4><strong>2. GitHub 與程式設計課程的關係</strong></h4>
<p><strong>GitHub</strong> 是基於 Git 的雲端代碼託管平台，提供在線存儲和版本控制服務。GitHub 的協作功能使得學生能夠將自己的程式碼上傳至雲端，並且與其他組員共享、協作開發，這對於程式設計課程中的團隊專案開發尤為重要。</p>
<h4><strong>操作流程：</strong></h4>
<p><strong>目的：</strong> 學生將本地程式碼推送到 GitHub 上，並通過協作功能進行合作開發。</p>
<ol>
<li><strong>創建 GitHub 倉庫：</strong>
<p>學生可以在 GitHub 上創建一個新倉庫，並將本地倉庫與之連接，通過 `git remote add` 和 `git push` 把程式碼推送到 GitHub。</p>
</li>
<li><strong>Fork 和 Pull Request：</strong>
<p>學生可以 Fork 他人的專案，修改後再向原專案發送 Pull Request，請求將修改合併到主專案中。</p>
</li>
</ol>
<h4><strong>優點：</strong></h4>
<ul>
<li><strong>協作功能：</strong> GitHub 使得學生能夠進行多人協作，並且能夠清晰地管理和合併不同組員的變更。</li>
<li><strong>雲端儲存：</strong> GitHub 提供雲端儲存，學生可以隨時訪問自己的程式碼，並且不需要擔心資料丟失。</li>
</ul>
<h4><strong>不使用 GitHub 的後果：</strong></h4>
<ul>
<li><strong>協作困難：</strong> 如果不使用 GitHub，學生之間的程式碼協作將變得繁瑣，難以管理變更，也難以追蹤問題。</li>
<li><strong>無法便捷共享：</strong> 學生無法像 GitHub 一樣方便地向他人展示自己的代碼，協作和交流會受到限制。</li>
</ul>
<h4><strong>3. Gist 與程式設計課程的關係</strong></h4>
<p><strong>Gist</strong> 是 GitHub 提供的代碼片段分享平台，適合學生分享小範圍的代碼段或程式設計題目的解法。Gist 使得學生能夠輕鬆展示學習過程中的代碼片段或共享一些學習心得。</p>
<h4><strong>操作流程：</strong></h4>
<p><strong>目的：</strong> 學生使用 Gist 快速分享代碼片段或小範例。</p>
<ol>
<li><strong>創建 Gist：</strong>
<p>學生可以將代碼片段粘貼到 Gist 網站，創建公開或私有的 Gist，並將其分享給其他人。</p>
</li>
</ol>
<h4><strong>優點：</strong></h4>
<ul>
<li><strong>代碼分享：</strong> 學生可以輕鬆分享自己的學習代碼片段，這對於同學之間的學習交流非常有幫助。</li>
<li><strong>簡單的版本控制：</strong> Gist 會自動為每個代碼片段建立版本控制，學生可以追蹤代碼的歷史變化。</li>
</ul>
<h4><strong>不使用 Gist 的後果：</strong></h4>
<ul>
<li><strong>難以分享學習成果：</strong> 學生如果不使用 Gist，將難以快速分享自己的代碼片段，學習過程中也無法有效地與他人進行交流。</li>
<li><strong>代碼存儲混亂：</strong> 代碼可能會散落在不同的地方，難以集中管理和查詢。</li>
</ul>
<h4><strong>4. CMSIMDE 與程式設計課程的關係</strong></h4>
<p><strong>CMSIMDE</strong> 是一種綜合開發環境，它融合了內容管理系統和集成開發環境（IDE）的功能，提供一個集中式的開發平台。在程式設計課程中，CMSIMDE 可以幫助學生更高效地開發、管理和協作程式碼。</p>
<h4><strong>優點：</strong></h4>
<ul>
<li><strong>提高開發效率：</strong> CMSIMDE 提供了一個統一的開發環境，學生可以在一個平台上進行編程、調試和版本管理，避免多重工具之間的切換。</li>
<li><strong>集成協作工具：</strong> CMSIMDE 可能包含像 GitHub 等協作工具，幫助學生進行多人協作開發。</li>
</ul>
<h4><strong>不使用 CMSIMDE 的後果：</strong></h4>
<ul>
<li><strong>開發效率低：</strong> 如果學生沒有使用 CMSIMDE，他們將需要在多個工具和平台之間切換，這會浪費時間並降低效率。</li>
<li><strong>難以協作：</strong> 沒有 CMSIMDE，學生將難以在一個平台上集中管理開發、測試和版本控制，協作會變得更加複雜。</li>
</ul><h1>Examples</h1>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<div id="brython_div1"></div>
<p>w5: <span>深入理解</span><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/e2502768ea4e0d13b33da0976b656a337e51ad42/cp_w4_robot_animation.py">機器人行走模擬程式</a><span>中的所有 Python 與 Brython 程式用法。</span></p>
<p><span style="background-color: #ffff00;">目前頁面已經有一個 div 標註, 其 id 設為 brython_div1, 請多舉幾個 brython browser 模組的 document, html, timer 以及 bind 的範例, 各舉十個範例, 讓我可以交作業.</span></p><h2>w5_1</h2>
<p>How can the robot be controlled via keyboard input from a remote user?</p>
<p><a href="https://mde.tw/cp2025/content/Brython.html?src=https://gist.githubusercontent.com/mdecycu/fa7d2a68d1569596f62e5b7739a83119/raw/e2502768ea4e0d13b33da0976b656a337e51ad42/cp_w4_robot_animation.py">機器人行走模擬程式</a></p>
<p>在頁面中嵌入 Brython 執行環境:</p>
<p style="padding-left: 30px;"><a href="/downloads/editor_embed_brython.txt">editor_embed_brython.txt</a></p>
<div id="brython_div1"></div>
<!-- 導入 brython 程式庫 -->
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
<script type="text/python3">
from browser import document, html, timer, bind

# 每個格子的像素大小
CELL_SIZE = 40

# 牆壁厚度，用於圖片位置調整
WALL_THICKNESS = 6

# 牆壁與機器人圖片的來源路徑
IMG_PATH = "https://mde.tw/cp2025/reeborg/src/images/"

# --- 定義世界地圖的類別 ---
class World:
    def __init__(self, width, height):
        self.width = width    # 地圖寬度（格子數）
        self.height = height  # 地圖高度（格子數）
        self.layers = self._create_layers()  # 建立多層 canvas 物件（背景、牆、物體、機器人）
        self._init_html()      # 初始化 HTML 容器
        self._draw_grid()      # 畫出網格線
        self._draw_walls()     # 畫出邊界牆壁

    def _create_layers(self):
        # 建立四個繪圖層，用於不同物件
        return {
            "grid": html.CANVAS(width=self.width * CELL_SIZE, height=self.height * CELL_SIZE),
            "walls": html.CANVAS(width=self.width * CELL_SIZE, height=self.height * CELL_SIZE),
            "objects": html.CANVAS(width=self.width * CELL_SIZE, height=self.height * CELL_SIZE),
            "robots": html.CANVAS(width=self.width * CELL_SIZE, height=self.height * CELL_SIZE),
        }

    def _init_html(self):
        # 建立容器 DIV，將四層 Canvas 疊起來
        container = html.DIV(style={
            "position": "relative",
            "width": f"{self.width * CELL_SIZE}px",
            "height": f"{self.height * CELL_SIZE}px"
        })

        for z, canvas in enumerate(self.layers.values()):
            canvas.style = {
                "position": "absolute",
                "top": "0px",
                "left": "0px",
                "zIndex": str(z)
            }
            container <= canvas

        # 手機用控制按鈕 UI
        button_container = html.DIV(style={"margin-top": "10px", "text-align": "center"})
        move_button = html.BUTTON("Move Forward (j)", id="move_button")
        turn_button = html.BUTTON("Turn Left (i)", id="turn_button")
        button_container <= move_button
        button_container <= turn_button

        # 插入到 HTML 指定位置
        document["brython_div1"].clear()
        document["brython_div1"] <= container
        document["brython_div1"] <= button_container

    def _draw_grid(self):
        # 畫格線
        ctx = self.layers["grid"].getContext("2d")
        ctx.strokeStyle = "#cccccc"
        for i in range(self.width + 1):
            ctx.beginPath()
            ctx.moveTo(i * CELL_SIZE, 0)
            ctx.lineTo(i * CELL_SIZE, self.height * CELL_SIZE)
            ctx.stroke()
        for j in range(self.height + 1):
            ctx.beginPath()
            ctx.moveTo(0, j * CELL_SIZE)
            ctx.lineTo(self.width * CELL_SIZE, j * CELL_SIZE)
            ctx.stroke()

    def _draw_image(self, ctx, src, x, y, w, h, offset_x=0, offset_y=0):
        # 載入圖片並繪製（用於牆壁、機器人）
        img = html.IMG()
        img.src = src
        def onload(evt):
            px = x * CELL_SIZE + offset_x
            py = (self.height - 1 - y) * CELL_SIZE + offset_y  # Y軸向上翻轉
            ctx.drawImage(img, px, py, w, h)
        img.bind("load", onload)

    def _draw_walls(self):
        # 畫四邊的牆壁
        ctx = self.layers["walls"].getContext("2d")
        for x in range(self.width):
            self._draw_image(ctx, IMG_PATH + "north.png", x, self.height - 1, CELL_SIZE, WALL_THICKNESS)
            self._draw_image(ctx, IMG_PATH + "north.png", x, 0, CELL_SIZE, WALL_THICKNESS, offset_y=CELL_SIZE - WALL_THICKNESS)
        for y in range(self.height):
            self._draw_image(ctx, IMG_PATH + "east.png", 0, y, WALL_THICKNESS, CELL_SIZE)
            self._draw_image(ctx, IMG_PATH + "east.png", self.width - 1, y, WALL_THICKNESS, CELL_SIZE, offset_x=CELL_SIZE - WALL_THICKNESS)

    def robot(self, x, y):
        # 畫出靜態機器人（初始位置）
        ctx = self.layers["robots"].getContext("2d")
        self._draw_image(ctx, IMG_PATH + "blue_robot_e.png", x - 1, y - 1, CELL_SIZE, CELL_SIZE)

# --- 定義動畫機器人類別 ---
class AnimatedRobot:
    def __init__(self, world, x, y):
        self.world = world
        self.x = x - 1
        self.y = y - 1
        self.facing = "E"  # 初始朝向
        self.facing_order = ["E", "N", "W", "S"]
        self.robot_ctx = world.layers["robots"].getContext("2d")
        self.trace_ctx = world.layers["objects"].getContext("2d")
        self.queue = []  # 動作佇列
        self.running = False
        self._draw_robot()

    def _robot_image(self):
        return {
            "E": "blue_robot_e.png",
            "N": "blue_robot_n.png",
            "W": "blue_robot_w.png",
            "S": "blue_robot_s.png"
        }[self.facing]

    def _draw_robot(self):
        self.robot_ctx.clearRect(0, 0, self.world.width * CELL_SIZE, self.world.height * CELL_SIZE)
        self.world._draw_image(self.robot_ctx, IMG_PATH + self._robot_image(), self.x, self.y, CELL_SIZE, CELL_SIZE)

    def _draw_trace(self, from_x, from_y, to_x, to_y):
        # 繪製路徑線條
        ctx = self.trace_ctx
        ctx.strokeStyle = "#d33"
        ctx.lineWidth = 2
        ctx.beginPath()
        fx = from_x * CELL_SIZE + CELL_SIZE / 2
        fy = (self.world.height - 1 - from_y) * CELL_SIZE + CELL_SIZE / 2
        tx = to_x * CELL_SIZE + CELL_SIZE / 2
        ty = (self.world.height - 1 - to_y) * CELL_SIZE + CELL_SIZE / 2
        ctx.moveTo(fx, fy)
        ctx.lineTo(tx, ty)
        ctx.stroke()

    def move(self, steps):
        def action(next_done):
            def step():
                nonlocal steps
                if steps == 0:
                    next_done()
                    return
                from_x, from_y = self.x, self.y
                dx, dy = 0, 0
                if self.facing == "E":
                    dx = 1
                elif self.facing == "W":
                    dx = -1
                elif self.facing == "N":
                    dy = 1
                elif self.facing == "S":
                    dy = -1
                next_x = self.x + dx
                next_y = self.y + dy

                if 0 <= next_x < self.world.width and 0 <= next_y < self.world.height:
                    self.x, self.y = next_x, next_y
                    self._draw_trace(from_x, from_y, self.x, self.y)
                    self._draw_robot()
                    steps -= 1
                    timer.set_timeout(step, 200)
                else:
                    print("已經撞牆，停止移動！")
                    next_done()
            step()
        self.queue.append(action)
        self._run_queue()

    def turn_left(self):
        def action(done):
            idx = self.facing_order.index(self.facing)
            self.facing = self.facing_order[(idx + 1) % 4]
            self._draw_robot()
            timer.set_timeout(done, 300)
        self.queue.append(action)
        self._run_queue()

    def _run_queue(self):
        if self.running or not self.queue:
            return
        self.running = True
        action = self.queue.pop(0)
        action(lambda: self._done())

    def _done(self):
        self.running = False
        self._run_queue()

# --- 主程式：建立地圖與機器人 ---
w = World(10, 10)
w.robot(1, 1)
r = AnimatedRobot(w, 1, 1)

# 綁定鍵盤控制
@bind(document, "keydown")
def keydown(evt):
    if evt.key == "j":
        r.move(1)
    elif evt.key == "i":
        r.turn_left()

# 綁定按鈕控制
@bind(document["move_button"], "click")
def move_click(evt):
    r.move(1)

@bind(document["turn_button"], "click")
def turn_click(evt):
    r.turn_left()

# 初始自動巡邏路線（可移除）
r.move(9)
r.turn_left()
r.move(9)
r.turn_left()
r.move(9)
r.turn_left()
r.move(9)
</script>
</p><h1>Brython</h1>
<p><a href="https://brython.info/">Brython</a> 是一個將 <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> 語法編譯為 <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript">JavaScript</a> 的工具，能直接在瀏覽器中以 <a href="https://en.wikipedia.org/wiki/Python_(programming_language)">Python</a> 撰寫前端網頁程式。</p>
<p><button id="add1to100">1 add to 100</button><button id="robot1">機器人巡邏</button><button id="free_walk">自由行</button></p>
<!-- 導入 brython 程式庫 -->
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 -->
<script src="/static/Cango-24v03-min.js"></script>
<script src="/static/gearUtils-09.js"></script>
<script src="/static/SVGpathUtils-6v03-min.js"></script>
<script src="/static/sylvester.js"></script>
<script src="/static/PrairieDraw.js"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p><!-- 累加程式開始 -->
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()
Ace1 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run1():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace1.editor.setValue(prog)
    Ace1.editor.scrollToRow(0)
    Ace1.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace1.run()
# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run1'].bind('click', Ace1.run)
doc['kw_show_console1'].bind('click', Ace1.show_console)
doc['kw_clear_console1'].bind('click', Ace1.clear_console)
doc['clear_bd1'].bind('click', clear_bd1)
# 呼叫函式執行
run1()
</script>
<!-- 累加程式結束 --> <!-- 機器人巡邏程式開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

robot1_url = "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/b33c5fc2a0774f8c5d2b0e8c7c7908e58d73bb94/robot_1.py"

# 從 gist 取得程式碼
robot1_src = open(robot1_url).read()
def robot1(ev):
    Ace2.editor.setValue(robot1_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "robot1" 的按鈕點按時, 執行 robot1 方法
doc["robot1"].bind('click', robot1)
</script>
<!-- 機器人巡邏程式結束 --></p>
<!-- 機器人自由行程式開始 -->
<p>
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

free_walk_url = "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9d55811467e411eb89f74171d8a586ae9f1a96aa/brython_robot_free_walk.py"

# 從 gist 取得程式碼
free_walk_src = open(free_walk_url).read()
def free_walk(ev):
    Ace2.editor.setValue(free_walk_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "free_walk" 的按鈕點按時, 執行 robot1 方法
doc["free_walk"].bind('click', free_walk)
</script>
</p>
<!-- 機器人自由行程式結束 -->
<p><!-- add 1 to 100 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add(ev):
    Ace2.editor.setValue(add_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "add1to100" 的按鈕點按時, 執行 add 方法
doc["add1to100"].bind('click', add)
</script>
</p>
<p><!-- add 1 to 100 結束--></p>
<!-- editor1 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src1', 'kw_filename1');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run1">Run</button> <button id="kw_show_console1">Output</button> <button id="kw_clear_console1">清除輸出區</button><button id="clear_bd1">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console1"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div1"></div>
<!-- editor1 結束 --><hr/><!-- ########################################## -->
<p>從 1 累加到 100 part2:</p>
<p><button id="add1to100part2">1 add to 100</button><button id="cango_three_gears">cango_three_gears</button><button id="bsnake">BSnake</button><button id="aitetris">AI Tetris</button></p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()
Ace3 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run2():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src2"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace3.editor.setValue(prog)
    Ace3.editor.scrollToRow(0)
    Ace3.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace3.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run2'].bind('click', Ace3.run)
doc['kw_show_console2'].bind('click', Ace3.show_console)
doc['kw_clear_console2'].bind('click', Ace3.clear_console)
doc['clear_bd2'].bind('click', clear_bd2)
# 呼叫函式執行
run2()
</script>
</p>
<p><!-- add 1 to 100 part2 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace4 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )

# 透過 Ace4 以類別建立一個通用的 button2, 可以在多個案例中將 gist 程導入編輯區

class button2:
    def __init__(self, url):
        self.url = url

    # 記得加入 event 輸入變數
    def do(self,ev):
        Ace4.editor.setValue(open(self.url).read())
        Ace4.editor.scrollToRow(0)
        Ace4.editor.gotoLine(0)
        Ace4.run()

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add2(ev):
    Ace4.editor.setValue(add_src)
    Ace4.editor.scrollToRow(0)
    Ace4.editor.gotoLine(0)
    Ace4.run()

# id 為 "add1to100part2" 的按鈕點按時, 執行 add 方法
doc["add1to100part2"].bind('click', add2)
# 以下為運用 button2 class 的通用 gist 程式導入區
################################## cango_three_gears start
cango_three_gears_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/cango_three_gears_brython_div2.py"
cango_three_gears = button2(cango_three_gears_url)
doc["cango_three_gears"].bind("click", cango_three_gears.do)
################################## cango_three_gears end
################################## bsnake start
bsnake_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/kmol_snakey.py"
bsnake = button2(bsnake_url)
doc["bsnake"].bind("click", bsnake.do)
################################## bsnake end
################################## aitetris start
aitetris_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/pygame_to_brython_tetris_ai.py"
aitetris = button2(aitetris_url)
doc["aitetris"].bind("click", aitetris.do)
################################## aitetris end
</script>
</p>
<p><!-- add 1 to 100 part2 結束--></p>
<!-- editor2 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename2" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src2', 'kw_filename2');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run2">Run</button> <button id="kw_show_console2">Output</button> <button id="kw_clear_console2">清除輸出區</button><button id="clear_bd2">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console2"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div2"></div>
<!-- editor2 結束 --><hr/>
<p></p><h2>Pyodide3</h2>
<p>Pyodide3 則在 <a href="https://mde.tw/cp2025/content/Pyodide.html">Pyodide</a> 與 <a href="https://mde.tw/cp2025/content/Pyodide2.html">Pyodide2</a> 頁面架構下，進一步導入 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/robot_w_world.py">robot_w_world.py</a>，在既有的水平圍牆 <a href="https://mde.tw/cp2025/reeborg/src/images/north.png">north.png</a> 與垂直圍牆 <a href="https://mde.tw/cp2025/reeborg/src/images/east.png">east.png</a> 檔案之外，加入 <a href="https://mde.tw/cp2025/reeborg/src/images/carrot.png">carrot.png</a>、<a href="https://mde.tw/cp2025/reeborg/src/images/grass.png">grass.png</a> 與 <a href="https://mde.tw/cp2025/reeborg/src/images/pale_grass.png">pale_grass.png</a> 等圖檔。並且擴充可從 URL 讀進 json 格式的 world 變數功能，以便製作出更多元的場景任務，要求機器人執行。</p>
<p>其中 src URL 變數，可以將網路上的機器人控制程式導入 Pyodide3 頁面外，world URL 變數則可以導入源自 <a href="https://mde.tw/reeborg">Reeborg</a> 機器人程式所設定的 json 格式場景。</p>
<p>由於 Reeborg 系統中的 png 圖檔均非透明背景，<a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/robot_w_world.py">robot_w_world.py</a> 必須利用 HTML 中的 CANVAS，將關鍵的白色背景，以透明的方式顯示。</p>
<p>src URL 變數讀進 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/8ac3ce859d6aec327b7859e091168270d6a951f7/pyodide2_turn_right.py">turn_right 程式</a>，而 world URL 變數則讀進 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/43517f3f54a5ac24d55d5a5cf8d316e6db2f3b65/harvest2.json">harvest2.json</a>，執行<a href="https://mde.tw/cp2025/content/Pyodide3.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/8ac3ce859d6aec327b7859e091168270d6a951f7/pyodide2_turn_right.py&amp;world=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/43517f3f54a5ac24d55d5a5cf8d316e6db2f3b65/harvest2.json">結果</a>。</p>
<p>讀進 <a href="https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/1b1c26eca7f5d772c6301bae865efaddb00a87bb/harvest3.json">harvest3.json</a>, 執行<a href="https://mde.tw/cp2025/content/Pyodide3.html?src=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/8ac3ce859d6aec327b7859e091168270d6a951f7/pyodide2_turn_right.py&amp;world=https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/harvest3.json">結果</a>。</p>
<p>
<script src="https://cdn.jsdelivr.net/pyodide/v0.26.4/full/pyodide.js"></script>
</p>
<p><button id="version">version</button> <button id="hello_button">hello</button> <button id="add1to100">1 add to 100</button> <button id="robot1">機器人巡邏</button> <button id="free_walk">自由行</button> <button id="numpy_ode">numpy_ode</button></p>
<!-- Ace Editor Scripts -->
<p>
<script src="/static/ace/FileSaver.min.js"></script>
<script src="/static/ace/filereader.js"></script>
<script src="/static/ace/ace.js"></script>
<script src="/static/ace/ext-language_tools.js"></script>
<script src="/static/ace/mode-python.js"></script>
<script src="/static/ace/snippets/python.js"></script>
</p>
<!-- Editor 1 -->
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><button id="kw_run1">Run</button> <button id="kw_output1">Output</button> <button id="kw_clear_console1">清除輸出區</button> <button onclick="location.reload()">Reload</button></p>
<p><textarea id="kw_console1"></textarea></p>
<div id="pyodide_div1"></div>
<div id="mpl_output1"></div>
<div id="brython_div1"></div>
<hr/>
<p>從 1 累加到 100 part2:</p>
<p><button id="add1to100part2">1 add to 100</button></p>
<!-- Editor 2 -->
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><button id="kw_run2">Run</button> <button id="kw_output2">Output</button> <button id="kw_clear_console2">清除輸出區</button> <button onclick="location.reload()">Reload</button></p>
<p><textarea id="kw_console2"></textarea></p>
<div id="pyodide_div2"></div>
<div id="mpl_output2"></div>
<div id="brython_div2"></div>
<p>
<script>
function getUrlParam(key) {
  return new URLSearchParams(window.location.search).get(key);
}
function updateUrlParam(key, value) {
  const url = new URL(window.location);
  url.searchParams.set(key, value);
  window.history.replaceState({}, "", url);
}

let pyodide, editor1, editor2;

// 新增：把 robot_w_world.py 寫入 pyodide FS
async function loadRobotModule() {
  const robotUrl = "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/9f43571ec070ea3e24b083525ee27275a96efcc8/robot_w_world.py";
  const r = await fetch(robotUrl);
  if (!r.ok) throw new Error(`載入 robot.py 失敗: ${r.status}`);
  const code = await r.text();
  pyodide.FS.writeFile("/robot.py", code);
  pyodide.runPython(`import sys; sys.path.append("/")`);  // 加入根目錄到 sys.path
}

document.addEventListener("DOMContentLoaded", async () => {
  editor1 = ace.edit("kw_editor1");
  editor1.setTheme("ace/theme/chrome");
  editor1.session.setMode("ace/mode/python");

  editor2 = ace.edit("kw_editor2");
  editor2.setTheme("ace/theme/chrome");
  editor2.session.setMode("ace/mode/python");

  pyodide = await loadPyodide();
  await pyodide.loadPackage(["numpy", "scipy", "matplotlib", "micropip"]);

  // 預先載入 robot.py
  await loadRobotModule();

  // 你現有的 hello() 定義
  const code = `
def hello():
    print("Hello from custom module!")
`;
  pyodide.runPython(code);

  // 這是你之前其他按鈕用的 Gist 連結
  const GIST_ADD1TO100 =
    "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/" +
    "c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py";
  const NUMPY_ODE =
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" +
    "98d582539545b3c9fbfa35dd3e605c506367618e/pyodide_ode_ex1.py";
  const PYODIDE_ROBOT_ANIMATION =
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" +
    "ff833d14181c7e270d37432aa8589f5ecf00e383/pyodide_walk_around2.py";
  const FREE_WALK = 
    "https://gist.githubusercontent.com/mdecycu/ec4bb35dd0769e7a83d2a9fa57878a67/raw/" + "2a66dceb4a1dbdd0c384d4d17453f1e4f03f2493/pyodide_free_walk2.py"

  // 預設載入 GIST_ADD1TO100（或 URL 參數決定）
  const src = getUrlParam("src");
  if (src === PYODIDE_ROBOT_ANIMATION) {
    const robotCode = await fetchCode(PYODIDE_ROBOT_ANIMATION);
    editor1.setValue(robotCode, -1);
    updateUrlParam("src", PYODIDE_ROBOT_ANIMATION);
    runPyodide(editor1, "kw_console1", "brython_div1");
  } else {
    const initialCode = await fetchCode(src || GIST_ADD1TO100);
    editor1.setValue(initialCode, -1);
    runPyodide(editor1, "kw_console1", "brython_div1");
  }

  editor2.setValue("", -1);

  // 按鈕事件
  document.getElementById("version").onclick = () => {
    const vcode = `
import pyodide
import sys
import matplotlib
import numpy
import scipy
print("Pyodide version:", pyodide.__version__)
print("Python version :", sys.version)
print("matplotlib version:", matplotlib.__version__)
print("numpy version:", numpy.__version__)
print("scipy version:", scipy.__version__)
`;
    editor1.setValue(vcode, -1);
    updateUrlParam("src", "inline_version");
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("hello_button").onclick = () => {
    editor1.setValue("hello()", -1);
    updateUrlParam("src", "inline_hello");
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("add1to100").onclick = async () => {
    const c = await fetchCode(GIST_ADD1TO100);
    editor1.setValue(c, -1);
    updateUrlParam("src", GIST_ADD1TO100);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("numpy_ode").onclick = async () => {
    const c = await fetchCode(NUMPY_ODE);
    editor1.setValue(c, -1);
    updateUrlParam("src", NUMPY_ODE);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("robot1").onclick = async () => {
    const rc = await fetchCode(PYODIDE_ROBOT_ANIMATION);
    editor1.setValue(rc, -1);
    updateUrlParam("src", PYODIDE_ROBOT_ANIMATION);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("free_walk").onclick = async () => {
    const rc = await fetchCode(FREE_WALK);
    editor1.setValue(rc, -1);
    updateUrlParam("src", FREE_WALK);
    runPyodide(editor1, "kw_console1", "brython_div1");
  };

  document.getElementById("add1to100part2").onclick = async () => {
    const c = await fetchCode(GIST_ADD1TO100);
    editor2.setValue(c, -1);
    runPyodide(editor2, "kw_console2", "brython_div2");
  };

  document.getElementById("kw_run1").onclick = () =>
    runPyodide(editor1, "kw_console1", "brython_div1");
  document.getElementById("kw_run2").onclick = () =>
    runPyodide(editor2, "kw_console2", "brython_div2");
  document.getElementById("kw_clear_console1").onclick = () =>
    clearOutput("kw_console1", "brython_div1");
  document.getElementById("kw_clear_console2").onclick = () =>
    clearOutput("kw_console2", "brython_div2");
});

// 調整 output textarea 行數
document.getElementById("kw_output1").onclick = () => {
  const ta = document.getElementById("kw_console1");
  ta.rows = "15";
  ta.cols = "70";
  ta.scrollTop = 0;
};
document.getElementById("kw_output2").onclick = () => {
  const ta = document.getElementById("kw_console2");
  ta.rows = "15";
  ta.cols = "70";
  ta.scrollTop = 0;
};

async function fetchCode(url) {
  const r = await fetch(url);
  if (!r.ok) throw new Error(`載入失敗 ${r.status}`);
  return await r.text();
}

function clearOutput(consoleId, divId) {
  document.getElementById(consoleId).value = "";
  document.getElementById(divId).innerHTML = "";
}

async function runPyodide(editor, consoleId, divId) {
  document.getElementById(consoleId).value = "";
  document.getElementById(divId).innerHTML = "";

  await pyodide.runPythonAsync(`
import sys
class JsWriter:
  def write(self, s):
    from js import document
    ta = document.getElementById("${consoleId}")
    ta.value += s
    ta.scrollTop = ta.scrollHeight
sys.stdout = JsWriter()
sys.stderr = JsWriter()
`);

  try {
    await pyodide.runPythonAsync(editor.getValue());
  } catch (e) {
    document.getElementById(consoleId).value += "\\n錯誤：" + e.toString();
  }
}
</script>
</p>